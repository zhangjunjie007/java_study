﻿﻿﻿# 谈谈RPC 和 http

[视频地址](https://www.bilibili.com/video/BV1Qv4y127B4/?spm_id_from=333.337.search-card.all.click)

> **RPC：Remote Procedure Call，远程过程调用**

一直以来都没有深究过RPC和HTTP的区别，不都是写一个服务然后在客户端调用么？

HTTP和RPC最本质的区别，就是 **RPC 主要是基于 TCP/IP 协议的**，而 **HTTP 服务主要是基于 HTTP 协议的**。

我们都知道 HTTP 协议是在传输层协议 TCP 之上的，所以效率来看的话，RPC 当然是要更胜一筹啦！

HTTP和RPC的相同点是，底层通讯都是基于socket，都可以实现远程调用，都可以实现服务调用服务

### HTTP 的本质

首先你要明确 HTTP 是一个协议，是一个超文本传输协议。

HTTP 它是协议，不是运输通道。

它基于 TCP/IP 来传输文本、图片、视频、音频等。

重点来了。

HTTP 不提供数据包的传输功能，也就是数据包从浏览器到服务端再来回的传输和它没关系。

这是 TCP/IP 干的。

那 HTTP 有啥用？我们来分析一波。

我们上网要么就是获取一些信息来看，要么就是修改一些信息。

比如你用浏览器刷微博就是获取信息，发微博就是修改信息。

所以说浏览器需要告知服务器它需要什么，这次的请求是要获取哪些信息？发怎么样的微博。

这就涉及到浏览器和服务器之间的通信交互。

而交互就需要一种格式。

像你我之间的谈话就用中文，你要突然换成俄语我听不懂那不就 GG 了。

所以说 HTTP 它规定了一种格式，一种通信格式，大家都用这个格式来交谈。

这样不论你是什么服务器、什么浏览器都能顺利的交流，减少交互的成本。

就像全世界如果都讲中文，那我们不就不需要学英文了，那不就较少交互的成本了。

不像现在我们还得学英文，不然就看不懂文档等等。

万一之后俄语又起来了，咱还得对接俄文，这交互成本是不是就上来了。

而网络世界还好，咱们现在的 Web 交互基本上就是 HTTP 了。

其实 HTTP 协议的格式很像我们信封，有个固定的格式。

![alt](https://upload-images.jianshu.io/upload_images/6943526-1cdab6a28767865c?imageMogr2/auto-orient/strip)

左上角写邮编，右上角贴邮票，然后地址姓名啥的依次来。

因为计算机是很死板的，不像我们人一样有一种立体扫描感，所以要规定先写头、再写尾。

你要是先写尾，再写头计算机就认不出来了。

所以 HTTP 就规定了请求先搞请求行、再搞请求报头、再搞请求体。

响应就状态行、响应报头、响应体。

![](https://upload-images.jianshu.io/upload_images/6943526-e8974cac3b44ed13?imageMogr2/auto-orient/strip|imageView2/2/w/1080/format/webp)]

所以 HTTP 的本质是什么？

**就是客户端和服务端约定好的一种通信格式。**

### HTTP 和 RPC 的关系

HTTP 和 RPC 其实是两个维度的东西， HTTP 指的是通信协议。

而 RPC 则是远程调用，其对应的是本地调用。

RPC 的通信可以用 HTTP 协议，也可以自定义协议，是不做约束的。

像之前的单体时代，我们的 service 调用就是自己实现的方法，是本地进程内的调用。

```java
public User getUserById(Long id) {
       return userDao.getUserById(id); // 这叫本地调用
    }
```

现在都是微服务了，根据业务模块做了不同的拆分，像用户的服务不用我这个小组负责，我这小组只要写订单服务就行了。

但是我们服务需要用到用户的信息，于是我们需要调用用户小组的服务，于是代码变成了以下这种

```java
public User getUserById(Long id) {
       return userConsumer.getUserById(id); // 这是远程调用，逻辑是用户小组的服务实现的。
 }
```

可能还有些小伙伴不太清楚，再来看个图。

![](https://upload-images.jianshu.io/upload_images/6943526-6b7bb733274d3c2f?imageMogr2/auto-orient/strip|imageView2/2/w/1080/format/webp)]

把之前的用户实现拆分出来弄了一个用户服务，订单相关的也拆成了订单服务，都单独部署。

这样订单相关的服务要获取用户的信息就需要远程调用了。

可以看到 RPC 就是通过网络进行远程调用，订单服务其实就是客户端，而用户服务是服务端。

这又涉及到交互了，所以也需要约定一个格式，至于要不要用 HTTP 这个格式，就是大家自己看着办。

至此相信你对 HTTP 是啥也清楚了。

RPC 和 HTTP 的之间的关系也清楚了。

### 那为什么要有 RPC？

可能你常听到什么什么之间是 RPC 调用的，那你有没有想过为什么要 RPC， 我们直接 WebClient HTTP 调用不行么？

其实 RPC 调用是因为服务的拆分，或者本身公司内部的多个服务之间的通信。

服务的拆分独立部署，那服务间的调用就必然需要网络通信，用 WebClient 调用当然可行，但是比较麻烦。

我们想即使服务被拆分了但是使用起来还是和之前本地调用一样方便。

所以就出现了 RPC 框架，来屏蔽这些底层调用细节，使得我们编码上还是和之前本地调用相差不多。

并且 HTTP 协议比较的冗余，RPC 都是内部调用所以不需要太考虑通用性，只要公司内部保持格式统一即可。

所以可以做各种定制化的协议来使得通信更高效。

比如规定 yes 代表 yes的练级攻略，你看是不是更高效了，少传输的 5 个字。

就像特殊行动的暗号，高效简洁！

所以公司内部服务的调用一般都用 RPC，而 HTTP 的优势在于通用，大家都认可这个协议。

所以三方平台提供的接口都是通过 HTTP 协议调用的。

所以现在知道为什么我们调用第三方都是 HTTP ，公司内部用 RPC 了吧？

上面这段话看起来仿佛 HTTP 和 RPC 是对等关系，不过相信大家看了之前的解析心里应该都有数了。

下面来具体说一说 RPC 服务和 HTTP 服务的区别。

### OSI 网络七层模型

在说 RPC 和 HTTP 的区别之前，我觉的有必要了解一下 OSI 的七层网络结构模型（

![](https://upload-images.jianshu.io/upload_images/6943526-58602808f256e0bd?imageMogr2/auto-orient/strip|imageView2/2/w/778/format/webp)]

它可以分为以下几层：（从上到下）

- **第一层：应用层。**定义了用于在网络中进行通信和传输数据的接口。
- **第二层：表示层。**定义不同的系统中数据的传输格式，编码和解码规范等。
- **第三层：会话层。**管理用户的会话，控制用户间逻辑连接的建立和中断。
- **第四层：传输层。**管理着网络中的端到端的数据传输。
- **第五层：网络层。**定义网络设备间如何传输数据。
- **第六层：链路层。**将上面的网络层的数据包封装成数据帧，便于物理层传输。
- **第七层：物理层。**这一层主要就是传输这些二进制数据。

![](https://upload-images.jianshu.io/upload_images/6943526-95ecf6996957472a?imageMogr2/auto-orient/strip|imageView2/2/w/1080/format/webp)]

> **实际应用过程中，五层协议结构里面是没有表示层和会话层的。应该说它们和应用层合并了。**

我们应该将重点放在应用层和传输层这两个层面。因为 HTTP 是应用层协议，而 TCP 是传输层协议。

好，知道了网络的分层模型以后我们可以更好地理解为什么 RPC 服务相比 HTTP 服务要 Nice 一些！

## RPC 服务

从三个角度来介绍 RPC 服务，分别是：

- **RPC 架构**
- **同步异步调用**
- **流行的 RPC 框架**

**RPC 架构**

先说说 RPC 服务的基本架构吧。我们可以很清楚地看到，一个完整的 RPC 架构里面包含了四个核心的组件。

分别是：

- **Client**
- **Server**
- **Client Stub**
- **Server Stub（这个Stub大家可以理解为存根）**

![](https://upload-images.jianshu.io/upload_images/6943526-1e9048626457fb6c?imageMogr2/auto-orient/strip|imageView2/2/w/1080/format/webp)]

分别说说这几个组件：

- **客户端（Client），**服务的调用方。
- **服务端（Server），**真正的服务提供者。
- **客户端存根，**存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。
- **服务端存根**，接收客户端发送过来的消息，将消息解包，并调用本地的方法。

RPC 主要是用在大型企业里面，因为大型企业里面系统繁多，业务线复杂，而且效率优势非常重要的一块，这个时候 RPC 的优势就比较明显了。

![alt](https://img-blog.csdnimg.cn/img_convert/e83bdfd810f8e9aea081b6f62cf01c01.png)

比如我们有一个处理订单的系统服务，先声明它的所有的接口，然后将整个项目打包，服务端这边引入，然后实现相应的功能，客户端这边也只需要引入就可以调用了。

为什么这么做？

主要是为了减少客户端这边的包大小，因为每一次打包发布的时候，包太多总是会影响效率。

另外也是将客户端和服务端解耦，提高代码的可移植性。

**同步调用与异步调用**

什么是同步调用？什么是异步调用？

同步调用就是客户端等待调用执行完成并返回结果。

异步调用就是客户端不等待调用执行完成返回结果，不过依然可以通过回调函数等接收到返回结果的通知。如果客户端并不关心结果，则可以变成一个单向的调用。

### 流行的 RPC 框架

目前流行的开源 RPC 框架还是比较多的。下面重点介绍三种：

**①gRPC** 是 Google 最近公布的开源软件，基于最新的 HTTP2.0 协议，并支持常见的众多编程语言。

我们知道 HTTP2.0 是基于二进制的 HTTP 协议升级版本，目前各大浏览器都在快马加鞭的加以支持。

这个 RPC 框架是基于 HTTP 协议实现的，底层使用到了 Netty 框架的支持。

**②Thrift** 是 Facebook 的一个开源项目，主要是一个跨语言的服务开发框架。它有一个代码生成器来对它所定义的 IDL 定义文件自动生成服务代码框架。

用户只要在其之前进行二次开发就行，对于底层的 RPC 通讯等都是透明的。不过这个对于用户来说的话需要学习特定领域语言这个特性，还是有一定成本的。

**③Dubbo** 是阿里集团开源的一个极为出名的 RPC 框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是及其鲜明的特色。

## HTTP 服务

通常，我们的开发模式一直定性为 HTTP 接口开发，也就是我们常说的 RESTful 风格的服务接口。

的确，对于在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。

利用现成的 HTTP 协议进行传输。

平时的工作主要就是进行接口的开发，还要写一大份接口文档，严格地标明输入输出是什么？说清楚每一个接口的请求方法，以及请求参数需要注意的事项等。

![alt](https://img-blog.csdnimg.cn/img_convert/e389bb8352ff1ee204f70209d1f6e787.png)

比如下面这个例子：

```http
POST http://www.httpexample.com/restful/buyer/info/shar
```

接口可能返回一个 JSON 字符串或者是 XML 文档。然后客户端再去处理这个返回的信息，从而可以比较快速地进行开发。

但是对于大型企业来说，内部子系统较多、接口非常多的情况下，RPC 框架的好处就显示出来了，首先就是长链接，不必每次通信都要像 HTTP 一样去 3 次握手什么的，减少了网络开销。

其次就是 RPC 框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。

## rpc和http 区别

> **为啥不能用HTTP请求，要用RPC调用?**

1、RPC是一个完整的远程调用方案，它通常包括**通信协议和序列化协议**

- ​		   **通信协议**包含http协议（如gRPC使用http2）、自定义报文的tcp协议（如dubbo）
- ​			**序列化协议**包含基于文本编码的xml、json，基于二进制编码的protobuf、hessian等

2、HTTP只是一个通信协议，不是一个完整的远程调用方案

**也就是说，`HTTP和RPC不是对等的概念`，用来比较不太合适**

> **为什么有些后端子系统之间是使用自定义tcp协议的rpc来做进程通信？而不是用HTTP协议呢**

首先，http协议是**支持连接池复用**的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接

然后，http也可以使用protobuf这种二进制编码协议对内容进行编码

也就是说连接建立与断开的开销和序列化协议并不是主要影响因素

二者最大的区别还是在**传输协议**上

http的传输协议中header部分有很多**冗余**的部分，像Content-Type、Last-Modified、Expires等

即使http body是使用二进制编码协议，header头的键值对却用了文本编码，非常占用字节数

而自定义的tcp协议，可以精简传输内容，传输效率更高。比如下面的自定义tcp协议的报文：

```js
1-4 byte，length
5-8 byte，type
9-16 byte，package_id
17-length+16 byte，package_data
```

报头占用的字节数也就只有16个byte，大大地减少了传输内容。高并发情况下，少几个字节，乘以巨大的请求数量，能带来庞大的收益

因此，对于性能要求比较高的系统来说，通常使用自定义tcp协议的rpc来做后端进程通信

​    其实使用http协议比较多的还是前后端的通信，原因在于主流网页游览器都支持http协议，而且http在缓存、幂等重试乃至cookie这种浏览器安全相关的方面做了很多功夫

# webSocket 和http

[观看视频](https://www.bilibili.com/video/BV1684y1k7VP/?spm_id_from=333.337.search-card.all.click&vd_source=f7c1ba83c4aef508fd68946015318efb)

## 什么是websocket

- WebSocket是HTML5下一种新的协议（websocket协议本质上是一个基于tcp的协议）
- 它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的
- Websocket是一个**持久化**的协议

## websocket的原理

1. websocket约定了一个通信的规范，通过一个握手的机制，客户端和服务器之间能建立一个类似tcp的连接，从而方便它们之间的通信
2. 在websocket出现之前，web交互一般是基于http协议的短连接或者长连接
3. websocket是一种全新的协议，不属于http无状态协议，协议名为"ws"

## websocket与http的关系

![](https://img-blog.csdnimg.cn/45259e81df6b4455bdcfcad460a3a8bf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAb2hhbmHvvIE=,size_20,color_FFFFFF,t_70,g_se,x_16)

>  **相同点：**
>
> 1. **都是基于tcp的，都是可靠性传输协议**
> 2. **都是应用层协议**

> **不同点：**
>
> 1. **WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息**
> 2. **HTTP是单向的**
> 3. **WebSocket是需要浏览器和服务器握手进行建立连接的**
> 4. **而http是浏览器发起向服务器的连接，服务器预先并不知道这个连接**

> **联系：**
>
> - WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的

> **总结（总体过程）：**
>
> 1. **首先，客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等；**
> 2. **然后，服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据；**
> 3. **最后，客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。**

## websocket解决的问题

### 1.http存在的问题

- http是一种无状态协议，每当一次会话完成后，服务端都不知道下一次的客户端是谁，需要每次知道对方是谁，才进行相应的响应，因此本身对于实时通讯就是一种极大的障碍
- http协议采用一次请求，一次响应，每次请求和响应就携带有大量的header头，对于实时通讯来说，解析请求头也是需要一定的时间，因此，效率也更低下
- 最重要的是，需要客户端主动发，服务端被动发，也就是一次请求，一次响应，不能实现主动发送

### 2.long poll(长[轮询](https://so.csdn.net/so/search?q=轮询&spm=1001.2101.3001.7020))

- 对于以上情况就出现了http解决的第一个方法——长轮询
- 基于http的特性，简单点说，就是客户端发起长轮询，如果服务端的数据没有发生变更，会 hold 住请求，直到服务端的数据发生变化，或者等待一定时间超时才会返回。返回后，客户端又会立即再次发起下一次长轮询
- 优点是解决了http不能实时更新的弊端，因为这个时间很短，发起请求即处理请求返回响应，实现了“伪·长连接”
- 张三取快递的例子，张三今天一定要取到快递，他就一直站在快递点，等待快递一到，立马取走

>  从例子上来看有个问题：
>
> 1. 假如有好多人一起在快递站等快递，那么这个地方是否足够大，（抽象解释：需要有很高的并发，同时有很多请求等待在这里）

总的来看：

- 推送延迟。服务端数据发生变更后，长[轮询](https://so.csdn.net/so/search?q=轮询&spm=1001.2101.3001.7020)结束，立刻返回响应给客户端。
- 服务端压力。长轮询的间隔期一般很长，例如 30s、60s，并且服务端 hold 住连接不会消耗太多服务端资源。

### 3.[Ajax](https://so.csdn.net/so/search?q=Ajax&spm=1001.2101.3001.7020)轮询

- 基于http的特性，简单点说，就是规定每隔一段时间就由客户端发起一次请求，查询有没有新消息，如果有，就返回，如果没有等待相同的时间间隔再次询问
- 优点是解决了http不能实时更新的弊端，因为这个时间很短，发起请求即处理请求返回响应，把这个过程放大n倍，本质上还是request = response
- 举个形象的例子（假设张三今天有个快递快到了，但是张三忍耐不住，就每隔十分钟给快递员或者快递站打电话，询问快递到了没，每次快递员就说还没到，等到下午张三的快递到了，but，快递员不知道哪个电话是张三的，（可不是只有张三打电话，还有李四，王五），所以只能等张三打电话，才能通知他，你的快递到了）

> 从例子上来看有两个问题：
>
> 1. 假如说，张三打电话的时间间隔为10分钟，当他收到快递前最后一次打电话，快递员说没到，他刚挂掉电话，快递入库了（就是到了），那么等下一次时间到了，张三打电话知道快递到了，那么这样的通讯算不算实时通讯？很显然，不算，中间有十分钟的时间差，还不算给快递员打电话的等待时间（抽象的解释：每次request的请求时间间隔等同于十分钟，请求解析相当于等待）
> 2. 假如说张三所在的小区每天要收很多快递，每个人都采取主动给快递员打电话的方式，那么快递员需要以多快的速度接到，其他人打电话占线也是问题（抽象解释：请求过多，服务端响应也会变慢）

- 总的来看，Ajax轮询存在的问题：

1. 推送延迟。
2. 服务端压力。配置一般不会发生变化，频繁的轮询会给服务端造成很大的压力。
3. 推送延迟和服务端压力无法中和。降低轮询的间隔，延迟降低，压力增加；增加轮询的间隔，压力降低，延迟增高

### 4.websocket的改进

一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实现了“真·长链接”，实时性优势明显。

![](https://img-blog.csdnimg.cn/b4f3c4efafd24359be26dc3166569f76.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAb2hhbmHvvIE=,size_20,color_FFFFFF,t_70,g_se,x_16)

WebSocket有以下特点：

- 是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。而HTTP长连接基于HTTP，是传统的客户端对服务器发起请求的模式。
- HTTP长连接中，每次数据交换除了真正的数据部分外，服务器和客户端还要大量交换HTTP header，信息交换效率很低。Websocket协议通过第一个request建立了TCP连接之后，之后交换的数据都不需要发送 HTTP header就能交换数据，这显然和原有的HTTP协议有区别所以它需要对服务器和客户端都进行升级才能实现（主流浏览器都已支持HTML5）

# 小结

RPC 服务和 HTTP 服务还是存在很多的不同点的，一般来说，RPC 服务主要是针对大型企业的，而 HTTP 服务主要是针对小企业的，因为 RPC 效率更高，而 HTTP 服务开发迭代会更快。

很多RPC框架包含了重试机制，路由策略，负载均衡策略，高可用策略，流量控制策略等等。 如果应用进程之间只使用HTTP协议通信，显然是无法完成上述功能的。

总之，选用什么样的框架不是按照市场上流行什么而决定的，而是要对整个项目进行完整地评估，从而在仔细比较两种开发框架对于整个项目的影响，最后再决定什么才是最适合这个项目的。

一定不要为了使用 RPC 而每个项目都用 RPC，而是要因地制宜，具体情况具体分析。

，而 HTTP 服务主要是针对小企业的，因为 RPC 效率更高，而 HTTP 服务开发迭代会更快。

很多RPC框架包含了重试机制，路由策略，负载均衡策略，高可用策略，流量控制策略等等。 如果应用进程之间只使用HTTP协议通信，显然是无法完成上述功能的。

总之，选用什么样的框架不是按照市场上流行什么而决定的，而是要对整个项目进行完整地评估，从而在仔细比较两种开发框架对于整个项目的影响，最后再决定什么才是最适合这个项目的。

一定不要为了使用 RPC 而每个项目都用 RPC，而是要因地制宜，具体情况具体分析。



---

---



  rpc是总称，http只是一种rpc实现。rpc有grpc，thrift，mina 这种，多得很。 普通rpc在性能和特性上比http好，但是http有个最大的好处，标准化和实现广泛。任何语言都实现了http的客户端服务器，2个不同程序交互简单太多。大部分程序都有http接口，你使用起来就方便。如果是grpc，你还得重新实现。运用最广泛的方案就是好方案。







![alt](https://img-blog.csdnimg.cn/img_convert/075346a9f647e9d85e5627d56e9b6e05.gif)
